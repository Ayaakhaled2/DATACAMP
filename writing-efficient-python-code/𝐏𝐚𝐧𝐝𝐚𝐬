ğğšğ§ğğšğ¬

- pandas is python library used for data analysis 
- pandas main data structure is " Data Frame " : tabular data 


 Since .iterrows() returns each DataFrame row as a tuple of (index, pandas Series) pairs, 
 you can either split this tuple and use the index and row-values separately (as you did with for i,row in pit_df.iterrows()), 
 or you can keep the result of .iterrows() in the tuple form (as you did with for row_tuple in pit_df.iterrows()).

If using i,row, you can access things from the row using square brackets (i.e., row['Team']).
If using row_tuple, you would have to specify which element of the tuple you'd like to access before grabbing the team name (i.e., row_tuple[1]['Team']).

With either approach, using .iterrows() will still be substantially faster than using .iloc



for indx , row in df.iterrows():
   print(index , row ) 
   
 - this will return a tuple : index , row 
 
 
 
 ğ¢ğ­ğğ« ğ­ğ®ğ©ğ¥ğğ¬:
 df.itertuples() : is an efficient way to iterate over the dataframe 
 - it return an obj called : namedtuple , one of the collections package , it is similar to tuple but have field accessable usig attribute lookup ( . ) 
 Remember, .itertuples() returns each DataFrame row as a special data type called a namedtuple.
 
 ğ“ğ¡ğ ğ¦ğšğ¢ğ§ ğğ¢ğŸğŸğğ«ğğ§ğœğ ğ›ğğ­ğ°ğğğ§ ğ¢ğ­ğğ«ğ«ğ¨ğ°ğ¬ ğšğ§ğ ğ¢ğ­ğğ«ğ­ğ®ğ©ğ¥ğğ¬
) to access a column in ğ¢ğ­ğğ«ğ«ğ¨ğ°ğ¬ you can use [] 

for row_tuples in df.iterrows():
    print( row_tuples[1]) #to return the columns 
- but ğ¢ğ­ğğ«ğ­ğ®ğ©ğ¥ğğ¬ : namedtuple dosenot support the [] 
for row_tuples in df.itertuples():
    print( row_tuples.attribute )
    ğ²ğ¨ğ® ğ¦ğ®ğ¬ğ­ ğ®ğ¬ğ ğğ¨ğ­ ğ­ğ¨ ğ«ğğŸğğ«eğ§ğœğ ğ­ğ¡ğ ğšğ­ğ­ğ«ğ¢ğ›ğ®ğ­ğ


 Remember, you need to use the dot syntax for referencing an attribute in a namedtuple.
 
 
 
 
 
 pandas alternative to looping:
 to avoid the loops in pandas : use apply function , it acts as Map function in python 
 - it used to apply the function the entire dataframe 
- ğ²ğ¨ğ® ğ¦ğ®ğ¬ğ­ ğ¬ğ©ğğœğ¢ğŸğ² ğ­ğ¡ğ ğšğ±ğ¢ğ¬ 
   ğŸ : ğœğ¨ğ¥ğ®ğ¦ğ§ğ¬ 
   ğŸ : ğ«ğ¨ğ°ğ¬


df,apply(lambda / function , axis = 0 , 1)


Apply sum() to each row of rays_df, only looking at the 'RS' and 'RA' columns, and specify the correct axis.
total_runs_scored = rays_df[['RS', 'RA']].apply(sum, axis=1)

# Convert numeric playoffs to text by applying text_playoffs()
textual_playoffs = rays_df.apply(lambda row: text_playoffs()(row[''Playoffs'']), axis=1)
print(textual_playoffs)

.apply() method let's you apply functions to all rows or columns of a DataFrame by specifying an axis.



Pandas : 
- pandas perform vectorized ( broadcasting ) 
operations like numpy , the operations executed on the entire dataset at once 


df['column'].values : return the rows of the columns as np array 


you can use the np array to perform the calculations on the df columns and it will be better in performnace nad runtime 

df['c1'].values - df['c2'].values 
