import pandas as pd #import pandas 


You've seen the four most common types of data manipulation: sorting rows, subsetting columns, subsetting rows, and adding new columns.
In a real-life data analysis, you can mix and match these four manipulations to answer a multitude of questions.
df.head() >> return the first few rows in the dataframe 
----------------------------------------------------------------
df.info()

- display the name of the columns 
- datatypes 
- whether they have a missing values 
----------------------------------------------------------------
df.shape 

- this is an attribute not a method 
- return a tuple of ( num of rows , num of columns ) 
-----------------------------------------------------------------
df.describe() 
- return summary statistics of numeric data 
- mean - median - count - std - 5 num summary
-----------------------------------------------------------------
dataframe has a 3 main components 

df.values: A two-dimensional NumPy array of values.
df.columns: An index of columns: the column names.
df.index: An index for the rows: either row numbers or row names.
-----------------------------------------------------------------
df.sort_values( column_name ) : to sort the dataframe by this columns 
df.sort_values( column_name , ascending = True / False ) : ascending > False : descending order 
df.sort_values( [ list of columns ] ) : to sort by multiple columns 
df.sort_values( [ list of columns ] , ascending = [ True , False .... ] ) 
-----------------------------------------------------------------------
df['column_name'] : to zoom in one column
df[ [ 'c1' , 'c2' ,,,, ] ] : to zoom in multiple columns 
------------------------------------------------------------------------
Subset the rows 

1) logical conditions 

df [ df [ 'column_name' ] > n ] 

date format : '2016-07-25' year - month - day 

2) using and / or 

df [ (df['column'] > n) & (df['c_name'] < n2)] 
- you need to add () for each conditions 


3) isin : isin method used to filter on multiple values of categorical values 

df['column'].isin([ list of values to filter in]) 

Subsetting data based on a categorical variable often involves using the "or" operator (|) to select rows from multiple categories. This can get tedious when you want all states in one of three different regions, for example. Instead, use the .isin() method, which will allow you to tackle this problem by writing one condition instead of three separate ones.

colors = ["brown", "black", "tan"]
condition = dogs["color"].isin(colors)
dogs[condition]

Using .isin() makes subsetting categorical variables a breeze.
----------------------------------------------------------------------------

Add a new columns to the dataframe 
1) mutating dataframe 
2) transforming dataframe 
3) feature engineering 

You can create new columns from scratch, but it is also common to derive them from other columns, for example, by adding columns together or by changing their units.



df['new_column'] = calculations to create the new columns 
---------------------------------------------------------------------------------
ð’ð®ð¦ð¦ðšð«ð² ð¬ð­ðšð­ð¢ð¬ð­ð¢ðœð¬

ð’ð®ð¦ð¦ðšð«ð² ð¬ð­ðšð­ð¢ð¬ð­ð¢ðœð¬: a num that summarize and tell you about your dataset 

df['column'].mean()
df['column'].median()
df['column'].mode()
df['column'].var()
df['column'].std()
df['column'].sum()
df['column'].min()
df['column'].max()

ðšð ð  ðŸð®ð§ðœð­ð¢ð¨ð§:
df['column'].ðšð ð (function_name)

ðšð ð  ðŸð®ð§ðœð­ð¢ð¨ð§: allow to pass a fun / list of function to column / list of columns and it will apply the function on them 

df[[list of columns]].agg([ list of fun])
1) Min / max can be used with date column to return older / new 
2)Taking the minimum and maximum of a column of dates is handy for figuring out what time period your data covers. 

ðœð®ð¦ð®ð¥ðšð­ð¢ð¯ðž ð¬ð®ð¦: 

df['column'].cumsum() 
df['column'].cummin() 
df['column'].cummax()
df['column'].cumprod() 

- each one of them return a record for each row 

cumsum : first_value , v1 + v2 , v1 + v2 + v3 .... sum of all column 
----------------------------------------------------------------------------------------------------------------------------------
ð¬ð®ð¦ð¦ðšð«ð¢ð³ðž ðœðšð­ðžð ð¨ð«ð¢ðœðšð¥ ððšð­ðš ð®ð¬ð¢ð§ð  ðœð¨ð®ð§ð­

df.drop_duplicates(subset = 'column_name') >> drop duplcate values in this columns 
df.drop_duplicates(subset = [ "c1" , "c2" ]) 

df['c'].value_counts( sort = True / False ) 
df['c'].value_counts( normalize = True ) #return proportional of total 
var_name = df['c'].value_counts(sort=True, normalize=True)







